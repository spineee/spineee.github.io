<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Scanner</title>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #1e1e1e; color: #d4d4d4; padding: 20px; }
        #console { background: #000; border: 1px solid #444; padding: 15px; height: 500px; overflow-y: scroll; font-family: monospace; font-size: 12px; }
        .found { color: #4ec9b0; font-weight: bold; }
        .scanning { color: #569cd6; }
        .summary { margin-bottom: 10px; font-size: 1.1em; color: #ce9178; }
    </style>
</head>
<body>
    <h2>Subnet Scanner: 10.33.*.1</h2>
    <div class="summary" id="status">Initializing Scan...</div>
    <div id="console"></div>

    <script>
        const CONFIG = {
            baseIp: "10.33",
            port: 22,
            timeout: 1500,
            concurrency: 50 // Number of simultaneous requests
        };

        const consoleBox = document.getElementById('console');
        const statusBox = document.getElementById('status');
        let foundCount = 0;
        let scannedCount = 0;

        function log(message, className = "") {
            const entry = document.createElement('div');
            entry.className = className;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            consoleBox.appendChild(entry);
            consoleBox.scrollTop = consoleBox.scrollHeight;
        }

        async function checkHost(ip) {
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), CONFIG.timeout);
            
            try {
                // Fetching with no-cors to detect presence regardless of headers
                await fetch(`https://${ip}:${CONFIG.port}`, { mode: 'no-cors', signal: controller.signal });
                // If it doesn't throw a timeout or reset, it's likely alive
                foundCount++;
                log(`[+] FOUND: ${ip}:${CONFIG.port}`, "found");
            } catch (err) {
                if (err.name !== 'AbortError') {
                    // "Failed to fetch" usually means the port is closed or rejected, 
                    // but the IP is reachable.
                }
            } finally {
                clearTimeout(id);
                scannedCount++;
                updateStatus();
            }
        }

        function updateStatus() {
            statusBox.textContent = `Progress: ${scannedCount} / 65536 | Hosts Found: ${foundCount}`;
        }

        async function startBClassScan() {
            log(`Starting scan on ${CONFIG.baseIp}.0.0/16...`);
            
            let queue = [];
            for (let i = 0; i <= 255; i++) {
                const ip = `${CONFIG.baseIp}.${i}.1`;
                queue.push(ip);
            }

            // Simple worker pool to manage concurrency
            const workers = Array(CONFIG.concurrency).fill(null).map(async () => {
                while (queue.length > 0) {
                    const ip = queue.shift();
                    if (ip) await checkHost(ip);
                }
            });

            await Promise.all(workers);
            log("Scan completed.");
        }

        // Auto-start on load
        window.onload = startBClassScan;
    </script>
</body>
</html>
